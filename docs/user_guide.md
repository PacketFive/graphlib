# GraphLib User Guide

Welcome to the GraphLib User Guide. This document provides instructions on how to use the GraphLib library, focusing on its OSPF simulation capabilities with Mininet.

## Table of Contents

1.  [Introduction](#introduction)
2.  [Prerequisites](#prerequisites)
3.  [Setup](#setup)
4.  [Running the Mininet OSPF Simulation](#running-the-mininet-ospf-simulation)
5.  [Understanding the Simulation Output](#understanding-the-simulation-output)
6.  [Using Core Graph Library (Conceptual)](#using-core-graph-library-conceptual)

## 1. Introduction

GraphLib is a Python tool designed for network graph analysis and OSPF protocol simulation. Key components include:

*   **Core Graph Library:** For creating and manipulating generic directed, weighted graphs.
*   **OSPF Module:** Implements OSPF data structures (LSAs, Routers, Interfaces, Areas) and processes (LSA generation, LSDB management, SPF calculation).
*   **Mininet Importer:** A script that builds a network topology in Mininet, extracts its details, and runs an OSPF simulation using the OSPF module.

This guide primarily focuses on the `mininet_importer.py` script, which is the main entry point for observing the OSPF simulation.

## 2. Prerequisites

Before you begin, ensure you have the following installed:

*   **Python 3.x:** The library is developed using Python 3.
*   **Mininet:** Essential for running the network simulation. Installation instructions can be found on the [Mininet website](http://mininet.org/download/).
*   **Python Virtual Environment (Recommended):** To manage dependencies and avoid conflicts.

## 3. Setup

Follow these steps to set up GraphLib:

1.  **Obtain the Code:**
    If you cloned a Git repository:
    ```bash
    git clone <repository_url>
    cd graphlib 
    ```
    If you have the source code directly, navigate to the project's root directory (referred to as `graphlib/`).

2.  **Create and Activate a Python Virtual Environment:**
    It is highly recommended to use a virtual environment. From the project root directory:
    ```bash
    python3 -m venv /opt/pyvenv  # You can choose a different path, e.g., .venv
    source /opt/pyvenv/bin/activate
    ```
    If you created the venv elsewhere (e.g., in `./.venv`), activate it with `source .venv/bin/activate`.

3.  **Install Dependencies (if any):**
    If a `requirements.txt` file is provided, install the necessary Python packages:
    ```bash
    pip install -r requirements.txt
    ```
    The primary dependency for the simulation script is Mininet itself, which should be installed system-wide or be accessible to your Python environment.

## 4. Running the Mininet OSPF Simulation

The `graph_lib/mininet_importer.py` script is the main executable for the OSPF simulation.

**To run the simulation:**

Navigate to the project root directory (`graphlib/`).

*   **If your virtual environment is located at `/opt/pyvenv/` and is *not* currently activated:**
    You need to explicitly call the Python interpreter from the virtual environment.
    ```bash
    sudo /opt/pyvenv/bin/python -m graph_lib.mininet_importer
    ```
*   **If your virtual environment *is* activated in your current shell session:**
    You can directly use `python`.
    ```bash
    sudo python -m graph_lib.mininet_importer
    ```

**Why `sudo`?** Mininet requires root privileges to create and manage virtual network interfaces and switch configurations.

**Why `-m`?** The `-m` flag tells Python to run the specified module (`graph_lib.mininet_importer`) as a script. This helps Python correctly resolve imports within the `graph_lib` package.

**Interactive Mininet CLI:**

By default, the script runs the simulation, prints the output, and then cleans up the Mininet network. If you wish to interact with the Mininet topology directly via its Command Line Interface (CLI) after the simulation logic has completed, you can set the `INTERACTIVE_MININET_CLI` environment variable to `1`:

```bash
sudo INTERACTIVE_MININET_CLI=1 /opt/pyvenv/bin/python -m graph_lib.mininet_importer
```
Or, if your venv is activated:
```bash
sudo INTERACTIVE_MININET_CLI=1 python -m graph_lib.mininet_importer
```
Once the OSPF simulation details are printed, you will see the `mininet>` prompt. You can then use standard Mininet commands (e.g., `nodes`, `links`, `r1 ping r2`). Type `exit` or `quit` to leave the Mininet CLI and allow the script to finish cleaning up.

## 5. Understanding the Simulation Output

When you run `mininet_importer.py`, you will see several sections of output:

1.  **Mininet Initialization:** Logs related to creating Mininet nodes (routers, hosts, switches) and links.
2.  **IP Forwarding:** Confirmation that IP forwarding is enabled on the designated router nodes.
3.  **OSPF Simulation Initialization:**
    *   **LSA Origination:** Details of Router LSAs and Network LSAs being generated by each router (or DR for Network LSAs). This includes the LSA's Link State ID and the number of links/attached routers.
    *   **LSDB Population:** Confirmation of each LSA being added to the OSPF Area's Link State Database.
4.  **OSPF Intra-Area Routing Tables:**
    *   For each router in the OSPF simulation, its calculated routing table is displayed.
    *   Each entry shows:
        *   **Destination:** The target Router ID or Network ID (represented by a pseudo-node ID like `transit_10.0.1.3`).
        *   **Next Hop:** The Router ID of the next-hop router towards the destination, or the ID of a pseudo-node if the path traverses a transit network segment directly from the source. If `None`, it typically means the destination is the router itself.
        *   **Cost:** The total OSPF cost (metric) to reach the destination.
5.  **Generic Graph Conversion (Optional):**
    *   If this part of the script runs, it will show the number of nodes and edges in a generic graph representation derived from the Mininet topology.
    *   It will also list the node IDs (which are OSPF Router IDs) and edges (with their default OSPF cost).
6.  **Cleanup:** Mininet stopping the network and cleaning up virtual interfaces.

## 6. Using Core Graph Library (Conceptual)

While the `mininet_importer.py` script is the primary focus for OSPF simulation, the `graph_lib.graph` and `graph_lib.algorithms` modules provide general-purpose graph functionalities.

**Example (Illustrative - not run by the main importer script):**

```python
from graph_lib.graph import Graph
from graph_lib.algorithms import dijkstra

# Create a graph
g = Graph()
g.add_node("A", data={"info": "Node A"})
g.add_node("B")
g.add_node("C")

g.add_edge("A", "B", weight=5)
g.add_edge("B", "C", weight=3)
g.add_edge("A", "C", weight=10)

print(f"Nodes: {list(g.get_all_nodes())}")
print(f"Edges: {list(g.get_all_edges(include_weights=True))}")

# Calculate shortest path from A to C
cost, path = dijkstra(g, "A", "C")
if cost is not None:
    print(f"Shortest path from A to C: {path}, Cost: {cost}")
else:
    print("No path found from A to C")
```

This example shows basic graph creation, node/edge addition, and using Dijkstra's algorithm. Refer to the source code of these modules for more details on their APIs if you intend to use them directly.

---

This concludes the User Guide. For details on the internal workings or how to contribute, please see the [Developer Guide](./developer_guide.md). 